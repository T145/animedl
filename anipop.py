from os import path
from os import getcwd
from zipfile import ZipFile
from selenium import webdriver
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.common.exceptions import NoSuchElementException
from bs4 import BeautifulSoup as Soup
from collections import defaultdict
from qbittorrent import Client
import sys

sys.dont_write_bytecode = True


def get_browser():
    # profile generated by https://ffprofile.com/
    profile_path = path.normpath(path.join(getcwd(), 'profile'))
    profile_archive_path = profile_path + '.zip'

    if not path.exists(profile_path):
        if path.exists(profile_archive_path):
            with ZipFile('profile.zip', 'r') as archive:
                archive.extractall('profile')
        else:
            print('Missing Firefox profile definitions!')
            exit(1)

    profile = webdriver.FirefoxProfile(profile_directory=profile_path)
    opts = webdriver.FirefoxOptions()
    opts.headless = True
    return webdriver.Firefox(firefox_profile=profile,
                             options=opts, service_log_path=None)


def get_magnet(link):
    if link:
        a = link.find('a', attrs={'title': 'Magnet Link'})

        if a:
            return a['href']

    return None


def get_season():
    browser = get_browser()
    season = defaultdict(list)

    try:
        browser.get('https://horriblesubs.info/current-season/')
        page = Soup(browser.page_source, features='html.parser')
        shows = page.body('div', attrs={'class': 'ind-show'})

        for show in shows:
            title = show.a['title']
            url = 'https://horriblesubs.info{}/'.format(show.a['href'])

            browser.get(url)

            # Expand the whole listing to get all the episodes
            try:
                # Briefly wait to dodge `selenium.common.exceptions.ElementNotInteractableException`
                WebDriverWait(browser, 15).until(
                    EC.element_to_be_clickable((By.CLASS_NAME, 'more-button')))

                while True:
                    browser.find_element_by_class_name('more-button').click()
            except NoSuchElementException:
                pass

            page = Soup(browser.page_source, features='html.parser')
            batches = page.body.find('div', attrs={'class': 'batch-container'})
            episode_limit = 1

            print(title)

            if not batches['style']:
                for i, batch in enumerate(batches.find('div', attrs={'class': 'hs-batches'}).children):
                    if i == 0:
                        episode_limit = int(batch.strong.text.split('-')[1])

                    magnet = get_magnet(
                        batch('div', attrs={'class': 'rls-link'})[::-1][0])

                    if magnet:
                        season[title].insert(0, magnet)

            episodes = page.body.find(
                'div', attrs={'class': 'episode-container'})

            if not episodes['style']:
                for i, episode in enumerate(episodes.find('div', attrs={'class': 'hs-shows'}).children):
                    if i == 0:
                        episode_limit = int(episode['id']) - episode_limit

                    if i == episode_limit:
                        break

                    magnet = get_magnet(
                        episode('div', attrs={'class': 'rls-link'})[::-1][0])

                    if magnet:
                        season[title].insert(0, magnet)
    finally:
        browser.quit()
        return season


def get_dl_path():
    # TODO: Check if this drive has space, else check another drive
    # if there's no free space, crash
    return 'M:/'


if __name__ == "__main__":
    season = get_season()

    try:
        # Web UI -> 'Bypass authentication for hosts on localhost' should be enabled
        # Downloads -> 'Do not start download automatically' should be enabled
        qb = Client('http://127.0.0.1:8080/')

        # Use DP to decrease show fetch time
        for path, magnets in season.items():
            for magnet in magnets:
                qb.download_from_link(magnet, savepath='{}{}'.format(
                    get_dl_path(), path), category='anime')

        qb.resume_all()
    except ConnectionError:
        print('[!] qBittorrent not active!')
